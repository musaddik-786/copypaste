classifeir.py

from dotenv import load_dotenv
import os
import openai

openai.api_type = "azure"
openai.api_base = os.getenv("AZURE_OPENAI_ENDPOINT")
openai.api_version = os.getenv("AZURE_OPENAI_API_VERSION")
openai.api_key = os.getenv("AZURE_OPENAI_API_KEY")

deployment_name = os.getenv("AZURE_OPENAI_CHAT_DEPLOYMENT")

def classify_document(document_content):
    """
    Classifies the document layout as 'structured' or 'unstructured' based on text and table information.
    """
    text = document_content["text"]
    tables = document_content["tables"]

    # Prepare the prompt
    prompt = f"""
You are an AI assistant. Classify the following document layout as either 'structured' or 'unstructured'.

Structured documents typically contain tables, forms, or consistent layouts (e.g., insurance forms like ACORD). 
Unstructured documents contain free-form text, paragraphs, or inconsistent layouts (e.g., quote documents).

Document Text:
{text[:2000]}

Tables:
{tables if tables else "No tables detected"}

Reply with only one word: structured or unstructured.
"""

    response = openai.ChatCompletion.create(
        engine=deployment_name,
        messages=[{"role": "user", "content": prompt}],
        max_tokens=4,
        temperature=0.0  # Ensure deterministic responses
    )
    return response['choices'][0]['message']['content'].strip()

document_loader.py


from dotenv import load_dotenv
import os
from azure.ai.formrecognizer import DocumentAnalysisClient
from azure.core.credentials import AzureKeyCredential

# Load environment variables from .env file
load_dotenv()

# Fetch variables
endpoint = os.getenv("AZURE_FORMRECOG_ENDPOINT")
key = os.getenv("AZURE_FORMRECOG_KEY")
# Fail fast if missing
if not endpoint:
    raise ValueError(" AZURE_FORMRECOG_ENDPOINT is not set. Check your .env file.")
if not key:
    raise ValueError(" AZURE_FORMRECOG_KEY is not set. Check your .env file.")

# Create the client using the key and endpoint
client = DocumentAnalysisClient(endpoint=endpoint, credential=AzureKeyCredential(key))

def load_document(file_path):
    """
    Extracts text and layout information using Form Recognizer's prebuilt-layout model.
    """
    with open(file_path, "rb") as f:
        poller = client.begin_analyze_document("prebuilt-layout", document=f)
        result = poller.result()

    # Debugging: Print available attributes in DocumentPage
    print("Available attributes in DocumentPage:")
    print(dir(result.pages[0]))

    # Extract lines of text
    lines = [line.content for page in result.pages for line in page.lines]

    # Extract table information if available
    tables = []
    for page in result.pages:
        if hasattr(page, "tables"):  # Check if 'tables' attribute exists
            for table in page.tables:
                table_data = []
                for row in table.cells:
                    table_data.append(row.content)
                tables.append(table_data)

    # Combine text and table information
    document_content = {
        "text": "n".join(lines),
        "tables": tables if tables else "No tables detected"
    }
    return document_content



file_router.py
from fastapi import APIRouter
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field
from handler import classify_blob_pdf_layout

router = APIRouter()

class LayoutDetectRequest(BaseModel):
    """
    Payload:
    {
      "attachment_url": "https://<account>.blob.core.windows.net/<container>/<path>/file.pdf"
    }
    """
    attachment_url: str = Field(..., description="Full Azure Blob URL to the PDF attachment.")

@router.post("/layout_detection_mcp", operation_id="layout_detection_mcp",
             summary="Download PDF from blob, analyze layout using Form Recognizer, and classify layout")
async def detect_layout(request: LayoutDetectRequest):
    try:
        result = await classify_blob_pdf_layout(request.attachment_url)
        return JSONResponse(content={"jsonrpc": "2.0", "id": 1, "result": result}, status_code=200)
    except Exception as e:
        return JSONResponse(content={"jsonrpc": "2.0", "id": 1,
                                     "result": {"status": False, "error": str(e)}}, status_code=200)


handler.py

import os
import json
from typing import Dict, Any
from service import _require_env
from storage_utils import download_blob_to_input_folder
from document_loader import load_document
from classifier import classify_document

INPUT_FOLDER = "input"
OUTPUT_FOLDER = "output"

async def classify_blob_pdf_layout(blob_url: str) -> Dict[str, Any]:
    """
    - Download PDF into input/
    - Use Form Recognizer to analyze layout
    - Classify layout using extracted content
    - Return minimal verdict
    """
    try:
        _require_env()
    except Exception as e:
        return {"status": False, "error": f"Environment misconfigured: {e}"}

    # 1) Download PDF
    try:
        local_pdf = await download_blob_to_input_folder(blob_url, input_folder=INPUT_FOLDER)
    except Exception as e:
        return {"status": False, "error": f"Failed to download blob: {e}"}

    # 2) Use Form Recognizer to analyze the document
    try:
        document_content = load_document(local_pdf)
    except Exception as e:
        return {"status": False, "error": f"Form Recognizer failed: {e}"}

    # 3) Classify layout using extracted content
    try:
        layout_type = classify_document(document_content)
    except Exception as e:
        return {"status": False, "error": f"Classification failed: {e}"}

    result = {"status": True, "layout_type": layout_type, "details": document_content}

    # 4) Save minimal output to ./output
    try:
        os.makedirs(OUTPUT_FOLDER, exist_ok=True)
        out_path = os.path.join(OUTPUT_FOLDER, "layout_classification_result.json")
        with open(out_path, "w", encoding="utf-8") as f:
            json.dump(result, f, indent=2, ensure_ascii=False)
    except Exception as e:
        result["save_error"] = str(e)

    return result


main.py

# main.py
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
import uvicorn
from file_router import router as file_router

def apply_cors(app: FastAPI):
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_methods=["*"],
        allow_headers=["*"],
    )

app = FastAPI(title="Layout Detection MCP API", version="0.1.0")
apply_cors(app)
app.include_router(file_router, prefix="/api/v1/layout")

if __name__ == "__main__":
    uvicorn.run("main:app", host="0.0.0.0", port=8602, reload=False)



service.py
# service.py
#Working code 

import os
from urllib.parse import urlparse, unquote
from dotenv import load_dotenv

load_dotenv()

AZURE_STORAGE_CONNECTION_STRING = os.environ.get("AZURE_STORAGE_CONNECTION_STRING", "")

def _require_env() -> None:
    """Ensure required environment variables exist."""
    if not AZURE_STORAGE_CONNECTION_STRING:
        raise RuntimeError("Missing AZURE_STORAGE_CONNECTION_STRING in environment/.env")

def _parse_blob_url(url: str) -> tuple[str, str]:
    """
    Parse an Azure Blob URL and return (container_name, blob_path).
    Example URL:
      https://account.blob.core.windows.net/output-results/folder/name.pdf
    Returns:
      ("output-results", "folder/name.pdf")
    """
    parsed = urlparse(url)
    if not parsed.scheme.startswith("http"):
        raise ValueError("url must be a valid http(s) Azure Blob URL.")

    path = parsed.path.lstrip("/")
    if "/" not in path:
        raise ValueError("url must include both container and blob path.")
    parts = path.split("/", 1)
    container = parts[0]
    blob_path = parts[1]
    return unquote(container), unquote(blob_path)

storage_utils.py
#Working code 
# storage_utils.py
import os
import aiofiles
from azure.storage.blob.aio import BlobServiceClient
from azure.core.exceptions import ResourceNotFoundError
from service import AZURE_STORAGE_CONNECTION_STRING, _parse_blob_url

async def download_blob_to_input_folder(blob_url: str, input_folder: str = "input") -> str:
    """
    Downloads the blob at blob_url into input_folder (root-level) preserving filename.
    Returns the local path to the downloaded file.
    """
    if not AZURE_STORAGE_CONNECTION_STRING:
        raise RuntimeError("AZURE_STORAGE_CONNECTION_STRING not set")

    container, blob_path = _parse_blob_url(blob_url)
    filename = os.path.basename(blob_path)
    os.makedirs(input_folder, exist_ok=True)
    local_path = os.path.join(input_folder, filename)

    async with BlobServiceClient.from_connection_string(AZURE_STORAGE_CONNECTION_STRING) as service:
        container_client = service.get_container_client(container)
        blob_client = container_client.get_blob_client(blob_path)
        try:
            await blob_client.get_blob_properties()
        except ResourceNotFoundError:
            raise FileNotFoundError(f"Blob not found: container={container} blob={blob_path}")
        stream = await blob_client.download_blob()
        data = await stream.readall()

    # write file async
    async with aiofiles.open(local_path, "wb") as f:
        await f.write(data)

    return local_path



now i am trying to integrate it in the entore mcp end to end flow
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "status": false,
    "error": "Classification failed: \n\nYou tried to access openai.ChatCompletion, but this is no longer supported in openai>=1.0.0 - see the README at https://github.com/openai/openai-python for the API.\n\nYou can run `openai migrate` to automatically upgrade your codebase to use the 1.0.0 interface. \n\nAlternatively, you can pin your installation to the old version, e.g. `pip install openai==0.28`\n\nA detailed migration guide is available here: https://github.com/openai/openai-python/discussions/742\n"
  }
}


this is my current requirements.txt


fastapi==0.118.3
fastapi_mcp==0.4.0
uvicorn
python-dotenv
python-multipart
pandas
openpyxl
langchain
langchain-openai==0.3.35
langchain-community
faiss-cpu
openai
azure-ai-formrecognizer
azure-storage-blob
tiktoken
pymupdf

azure-ai-documentintelligence

aiohttp

azure-core
fastapi

langchain-mcp-adapters==0.1.11
langgraph==0.6.10
google-api-python-client
google-auth-oauthlib
google-auth-httplib2
google-cloud-pubsub
requests
aiofiles
Pillow
openai


#Rohans new code
google-auth
pydantic

# layout detection

# pywin32
openpyxl


