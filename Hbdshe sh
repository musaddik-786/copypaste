Yes — absolutely. The simplest safe approach is to ask the LLM (in the same prompt you already send) to also return a short human-readable reason, then print that reason in your terminal. Below I give a minimal, non-invasive change: keep the same text and tables inputs (you said don’t change inputs) but change the prompt so the model returns both a label and a one-line reason. I also include parsing that’s forgiving if the model replies slightly differently.

What to change (minimal)

Only change classifier.py — update classify_document so the prompt asks for the reason and the function returns (label, reason).

Replace your existing classify_document with the code below.

# classifier.py
from dotenv import load_dotenv
import os
import openai
import re

load_dotenv()
openai.api_type = "azure"
openai.api_base = os.getenv("AZURE_OPENAI_ENDPOINT")
openai.api_version = os.getenv("AZURE_OPENAI_API_VERSION")
openai.api_key = os.getenv("AZURE_OPENAI_API_KEY")

deployment_name = os.getenv("AZURE_OPENAI_CHAT_DEPLOYMENT")

def classify_document(document_content):
    """
    Returns: (label, reason)
    label -> 'structured' or 'unstructured'
    reason -> short one-line explanation of which features in the provided input influenced the decision
    """
    text = document_content.get("text", "")
    tables = document_content.get("tables", "No tables detected")

    prompt = f"""
You are an assistant that must classify a document layout as exactly one of:
  - structured
  - unstructured

You will be given two inputs:
1) Tables extracted (or 'No tables detected').
2) Document text (first 2000 characters shown).

Decide which label fits and then provide a **one-line reason** describing the specific signal(s) from the inputs that led to the decision (for example: "Tables detected (num_tables>0)", "Many label:value lines", "Long paragraphs and salutations", "Keyword 'ACORD' present", etc.)

**Reply in plain text with exactly two lines**:
First line: the label (structured or unstructured)
Second line: the reason (one short sentence)

Tables:
{str(tables)[:1200]}

Document text (first 2000 chars):
{text[:2000]}
"""

    response = openai.ChatCompletion.create(
        engine=deployment_name,
        messages=[{"role": "user", "content": prompt}],
        max_tokens=100,
        temperature=0.0
    )
    content = response['choices'][0]['message']['content'].strip()

    # Try to parse two-line response robustly
    lines = [ln.strip() for ln in content.splitlines() if ln.strip()]
    label = None
    reason = None

    if len(lines) >= 1:
        # first line may contain extra words; extract structured/unstructured token
        m = re.search(r"\b(structured|unstructured)\b", lines[0].lower())
        if m:
            label = m.group(1)
        else:
            # fallback: if first token looks like a word 'structured' or 'unstructured'
            first_word = lines[0].split()[0].lower()
            if first_word in ("structured", "unstructured"):
                label = first_word
            else:
                # try second line
                m2 = re.search(r"\b(structured|unstructured)\b", content.lower())
                label = m2.group(0) if m2 else "unknown"

    if len(lines) >= 2:
        reason = lines[1]
    else:
        # if only one line, try to extract rest after the label
        rest = content.lower().replace(label or "", "", 1).strip()
        reason = rest if rest else "No reason provided."

    return label, reason

Print the reason in main.py

Change how you call the classifier so you print both label and reason. Minimal change:

# main.py (only the printing part)
from document_loader import load_document
from classifier import classify_document

def main():
    print(" Document Layout Classifier")
    file_path = input("Enter the file path: ").strip()

    try:
        document_content = load_document(file_path)
        if not document_content["text"]:
            raise Exception("No readable content found.")

        layout_type, reason = classify_document(document_content)
        print(f"\n Document Layout: {layout_type}")
        print(f"Reason: {reason}")

    except Exception as e:
        print("Error:", e)

if __name__ == "__main__":
    main()

Example of expected terminal output

After this change you’ll see something like:

 Document Layout Classifier
Enter the file path: C:\...\Acord_125 (1).pdf

 Document Layout: structured
Reason: Tables detected (tables not empty) and keywords 'policy' and 'ACORD' present.

Or:

 Document Layout Classifier
Enter the file path: C:\...\Quote.pdf

 Document Layout: unstructured
Reason: Long paragraphs, salutations and no tables detected.

Notes & reliability
	•	This does not change the inputs your LLM sees (text/tables) — only asks the LLM to explain its own decision in a short line.
	•	Keep temperature=0.0 so the model is deterministic; still the wording may vary slightly, which is why parsing is forgiving.
	•	If the LLM ever fails to produce exactly two lines, the parser tries to recover and returns something reasonable.
	•	If you want the reason to be more structured (e.g., explicit mention of “tables” or “label:value”), you can tighten the prompt to force specific tokens — but the change above is the gentlest.

If you want, I can now give you a one-line ready-to-copy prompt variation that forces JSON output (label + reason) for stricter parsing — but the two-line approach above is simplest and very robust. Want the JSON version?
