import requests
from math import radians, cos, sin, asin, sqrt

# Helper: Haversine distance (km)
def haversine(lat1, lon1, lat2, lon2):
    # return distance in km
    R = 6371.0
    dlat = radians(lat2 - lat1)
    dlon = radians(lon2 - lon1)
    a = sin(dlat/2)**2 + cos(radians(lat1)) * cos(radians(lat2)) * sin(dlon/2)**2
    c = 2 * asin(min(1, sqrt(a)))
    return R * c

def query_fema_nfhl(lat, lon):
    # FEMA ArcGIS NFHL endpoint (FeatureServer layer 0 or appropriate layer)
    # Example query endpoint (ArcGIS REST query)
    base = "https://hazards.fema.gov/gis/nfhl/rest/services/public/NFHL/MapServer/0/query"
    params = {
        "geometry": f"{lon},{lat}",
        "geometryType": "esriGeometryPoint",
        "inSR": "4326",
        "spatialRel": "esriSpatialRelIntersects",
        "outFields": "FLD_ZONE",
        "f": "json"
    }
    r = requests.get(base, params=params, timeout=10)
    if r.status_code != 200:
        return None
    j = r.json()
    features = j.get("features", [])
    if not features:
        return {"in_zone": False}
    # may return multiple features; pick the first/most authoritative
    zone = features[0]["attributes"].get("FLD_ZONE")
    return {"in_zone": True, "zone": zone, "raw": features}

def find_nearest_usgs_gauge(lat, lon, max_km=20):
    # Use USGS monitoring-locations OGC endpoint to get nearby sites
    # This example uses the OGC "monitoring-locations" collection; adjust if required.
    base = "https://api.waterdata.usgs.gov/ogcapi/v0/collections/monitoring-locations/items"
    params = {
        "lat": lat,
        "lon": lon,
        "limit": 50
    }
    r = requests.get(base, params=params, timeout=10)
    if r.status_code != 200:
        return None
    j = r.json()
    items = j.get("features", [])
    best = None
    bestd = 99999
    for it in items:
        props = it.get("properties", {})
        geom = it.get("geometry", {})
        if not geom: continue
        gcoords = geom.get("coordinates", [])
        if len(gcoords) < 2: continue
        glon, glat = gcoords[0], gcoords[1]
        d = haversine(lat, lon, glat, glon)
        if d < bestd:
            bestd = d
            best = {"id": props.get("siteCode") or props.get("siteIdentifier") or props.get("identifier"),
                    "name": props.get("siteName") or props.get("name"),
                    "lat": glat, "lon": glon, "dist_km": d, "properties": props}
    if best and best["dist_km"] <= max_km:
        return best
    return None

def check_usgs_rtfi_nearby(lat, lon, radius_km=10):
    # RTFI API allows querying flood impact locations; we'll get impacts within a bbox
    # Simple approach: request RTFI list and find nearest impacted location
    base = "https://api.waterdata.usgs.gov/rtfi-api/rtfi/locations"
    # RTFI has its own query params (may change); use bbox approx
    # build a small bbox around lat/lon (rough)
    delta = 0.2  # ~22 km latitude roughly - tune as needed
    bbox = f"{lon-delta},{lat-delta},{lon+delta},{lat+delta}"
    r = requests.get(base, params={"bbox": bbox}, timeout=10)
    if r.status_code != 200:
        return None
    j = r.json()
    # check entries for 'is_impacted' or similar flags
    for loc in j.get("features", []):
        props = loc.get("properties", {})
        # property names may differ; check 'impacted' or 'flooding'
        if props.get("impactLevel") or props.get("isImpacted") or props.get("is_impacted"):
            # compute distance to verify
            geom = loc.get("geometry", {})
            coords = geom.get("coordinates", [None, None])
            if coords[0] is None:
                continue
            d = haversine(lat, lon, coords[1], coords[0])
            if d <= radius_km:
                return {"impacted": True, "distance_km": d, "properties": props}
    return {"impacted": False}

def is_flood_prone_us(lat, lon):
    # 1) FEMA mapped zones
    f = query_fema_nfhl(lat, lon)
    if f and f.get("in_zone"):
        zone = f.get("zone")
        high_risk = {"A","AE","AH","AO","VE","V","AR","A99"}
        if zone and zone.upper() in high_risk:
            return {"flood_prone": True, "reason": f"mapped_zone:{zone}"}
        else:
            # Not a high-risk regulatory zone
            return {"flood_prone": False, "reason": f"mapped_zone:{zone}"}

    # 2) USGS RTFI nearby impact
    rtfi = check_usgs_rtfi_nearby(lat, lon)
    if rtfi and rtfi.get("impacted"):
        return {"flood_prone": True, "reason": f"rtfi_nearby (dist_km={rtfi['distance_km']:.1f})"}

    # 3) Find nearest gauge and check instantaneous values / flood thresholds
    gauge = find_nearest_usgs_gauge(lat, lon, max_km=20)
    if gauge:
        site = gauge['id']
        # Instantaneous values API (example)
        iv_url = f"https://waterservices.usgs.gov/nwis/iv/?format=json&sites={site}&parameterCd=00065"  # 00065 = gage height
        r = requests.get(iv_url, timeout=10)
        if r.status_code == 200:
            data = r.json()
            # parse to get current stage and compare to flood threshold (you must get threshold from metadata)
            # For brevity, assume we can find a 'flood_stage' property in monitoring-locations metadata (not always present)
            flood_stage = None
            try:
                flood_stage = float(gauge['properties'].get('floodStage')) if gauge['properties'].get('floodStage') else None
            except:
                flood_stage = None
            # parse current value
            try:
                current = float(data['value']['timeSeries'][0]['values'][0]['value'][0]['value'])
            except Exception:
                current = None
            if current is not None and flood_stage is not None and current >= flood_stage:
                return {"flood_prone": True, "reason": f"gauge_{site}_above_flood_stage (current={current}, threshold={flood_stage})"}
    # 4) NWPS forecast fallback (left as future step) - call NWPS API for forecast point nearest to lat/lon and use forecast category.

    return {"flood_prone": False, "reason": "no_evidence_from_nfhl_rtfi_usgs_nwps"}
