Apologies for the earlier confusion. Let's realign our focus on the AI-powered First Notice of Loss (FNOL) Proof of Concept (POC) for motor vehicle claims, as previously discussed.


---

AI-Powered FNOL Transformation: Key Challenges and Solutions

01 Intelligent Damage Detection & Assessment

Challenge: Manual damage assessments are time-consuming and prone to inconsistencies, leading to delays in claim processing. 

Solution: Implement AI-driven computer vision systems that analyze uploaded vehicle images to identify and classify damages accurately. These systems can assess the severity and estimate repair costs, streamlining the initial assessment phase.  


---

02 Real-Time Customer Interaction & Feedback Loop

Challenge: Customers often face cumbersome processes when reporting claims, leading to dissatisfaction and potential errors in data collection. 

Solution: Deploy AI-powered chatbots and virtual assistants to guide customers through the FNOL process, ensuring accurate data capture and providing instant feedback. This enhances user experience and data reliability.  


---

03 Automated Claim Processing & Workflow Integration

Challenge: Traditional claim processing involves multiple manual steps, increasing the risk of errors and prolonging settlement times. 

Solution: Utilize AI to automate the extraction and validation of information from FNOL reports, integrating seamlessly with existing workflows to expedite claim processing and reduce manual intervention.  


---

04 Continuous Learning & Model Enhancement

Challenge: Static AI models may become outdated, reducing accuracy over time. 

Solution: Incorporate machine learning techniques that allow models to learn from new data and feedback continuously, improving accuracy in damage assessment and claim processing over time.  


---

05 Enhanced Fraud Detection & Risk Management

Challenge: Detecting fraudulent claims manually is challenging and resource-intensive. 

Solution: Implement AI algorithms that analyze patterns and anomalies in claims data to identify potential fraud, enabling proactive risk management.  


---

06 Comprehensive Reporting & Analytics

Challenge: Lack of real-time insights into claims data hampers decision-making and operational efficiency. 

Solution: Leverage AI to analyze large datasets, providing actionable insights into claim trends, operational performance, and customer satisfaction metrics, facilitating informed decision-making.  


---

07 Seamless Integration with Existing Systems

Challenge: Integrating new AI solutions with legacy systems can be complex and disruptive. 

Solution: Design AI solutions with compatibility in mind, ensuring they can integrate smoothly with existing insurance platforms through intelligent APIs, minimizing disruption and maximizing efficiency.  


---

If you require further elaboration on any of these components or assistance in developing detailed content for each, feel free to ask!




























“Create a responsive web dashboard for managing vehicle damage claims. Do not replicate any existing design, but include all these features in a fresh layout:

1. Global Header

Left: Logo placeholder + page title “Genius CLAIM”

Center: Vehicle summary line: 2016 BMW X3 xDrive28i (make, model, year) with VIN underneath

Right: User avatar icon, notification bell icon


2. Sidebar (left) – vertical navigation

Items: Summary, Front Left, Front Right, Rear Left, Rear Right

Highlight the active section (“Front Left”) with a bold accent color


3. Main Content Area (two columns)

Column A (damage map)

Large photo placeholder of the vehicle

Overlaid, semi-transparent colored shapes marking damaged zones (use teal for ‘inspect’, amber for ‘review’, gray for ‘ok’)

Label the current view (“Front Left”) at the top of the image

Timestamp or image ID in small text below


Column B (parts & actions)

Tabs at top: External Parts | Internal Parts

In each tab, list each part as a collapsible accordion item showing:

1. Part name (e.g. “Front Bumper”)


2. Price (e.g. “$1,273.33”)


3. Action selector: a dropdown with options “Replace,” “Repair,” or “None”


4. Review checkbox or toggle



At the bottom of the list, show totals: “Repair Cost: $6,395.06” and “ACV: $17,525”



4. Status indicators (top-right of main area)

Two circular icon badges with micro-text below:

Damage severity (use an icon + “Moderate”)

AI confidence (use a checkmark + “92%”)



5. Styling & tone

Clean, minimalist, plenty of white space

Accent colors: teal (#1FAAAA), amber (#F0A500), slate gray (#6B7280)

Rounded corners on cards, subtle drop-shadows

Sans-serif font (e.g. Inter or Roboto)


6. Responsive behavior

Collapse the sidebar into a top hamburger menu on narrow viewports

Parts accordions stretch full-width on mobile


“Use this spec to generate a new web page design—same functionality, different structure and styling.”


















Challenges of Insurance Contact Center

01 Surges of Claims enquiry calls during high demand periods like CAT events

Challenges of scalability and flexibility 
Difficult to handle High Volume of Customer Inquiries during CAT events

02 Policy enquiries to understand Policy Term, Coverage limits, Exclusions and Premium impact on change

Difficulty in making policy changes or 
Understanding the impact on premium for any change in Policy

03 Agent Burnout and Attrition & knowledge loss due to Attrition

Complex domain so requires significant investment in training
So, attrition increases recruitment & training Cost
service quality drop after attrition

04 Billing and Payments related enquiries 

Confusion regarding billing cycles, payment schedules, or discrepancies in charges
incorrect amounts billed, or delayed payments being processed

05 Enquiries related to Policy Renewal and payment

Reduced clarity on renewal terms and conditions
Understanding of the reason behind the increase in premium
Issues with the online payment 








































Certainly! Based on our previous discussions and the comprehensive insights gathered, here's an expanded and detailed transformation solution tailored for your AI-powered FNOL (First Notice of Loss) POC in motor vehicle claims:


---

AI-Powered FNOL Transformation Solution

1. Intelligent Damage Detection & Assessment

Automated Image Analysis: Utilize AI-driven computer vision to analyze uploaded images, identifying and classifying damages (e.g., dents, scratches, broken parts).  

Severity Estimation: Assess the extent of damage to determine repairability or total loss, aiding in swift claim decisions.  

Cost Prediction: Estimate repair costs using historical data and machine learning models, providing immediate feedback to customers.  


2. Real-Time Customer Interaction & Feedback Loop

Guided Image Capture: Implement in-app guidance to assist users in capturing optimal images for assessment.  

Instant Feedback Mechanism: Allow customers to review AI assessments and provide corrections or additional information, enhancing model accuracy over time.  


3. Automated Claim Processing & Workflow Integration

Instant Claim Generation: Automatically generate claim files upon image analysis, reducing manual entry and processing time.  

Smart Routing: Direct claims to appropriate adjusters or departments based on complexity and AI confidence levels.  

Status Updates: Provide real-time updates to customers regarding claim status, enhancing transparency and trust.  


4. Continuous Learning & Model Enhancement

Feedback Incorporation: Integrate customer and adjuster feedback into training datasets to refine AI models continually.  

Performance Monitoring: Regularly assess AI accuracy and processing times, implementing improvements as needed.  


5. Enhanced Fraud Detection & Risk Management

Anomaly Detection: Employ AI to identify inconsistencies or unusual patterns in claims, flagging potential fraud.  

Telematics Integration: Leverage vehicle data (e.g., speed, location) to validate claim details and detect discrepancies.  


6. Comprehensive Reporting & Analytics

Operational Dashboards: Monitor key metrics such as claim volumes, processing times, and customer satisfaction scores.  

Predictive Analytics: Forecast claim trends and potential risk areas, enabling proactive decision-making.  


7. Seamless Integration with Existing Systems

API Connectivity: Ensure compatibility with current insurance platforms, repair shop systems, and other third-party services.  

Modular Architecture: Design the solution to be scalable and adaptable to future technological advancements and business needs.  



---

This comprehensive approach ensures a streamlined, efficient, and customer-centric FNOL process, leveraging the latest in AI and automation technologies. If you need further details or assistance in developing specific components of this solution, feel free to ask!






















Underwriting Transformation - Solutions

01 Data and Analytics

Incorporating analytics & Reporting tools providing real time information

Incorporate analytics and reporting tools
Real-time insights into portfolio performance, risk trends, and other key metrics
For ex: 
Ops MI : Pipeline management MI such as untouched, WIP, completed, queried 
Pre-Bind MI: Submission/ Quote ratio, geo wise portfolio view, claims ratio, Quote/bind ratios
Post Bind: loss control, claims history, legal & compliance report, premium collection & allocation, aged debt,  reports 


02 Digital Workbench

Centralized control panel offering one stop shop solution

Centralized control panel, offering a one-stop-shop solution 
Optimises processes 
Facilitates efficient workflow, access to online documents and emails.
Paperless and collaborative features 
Single pain of glass to improve transparency
Digitising what is broken and connecting what is working well


03 Intelligent Document Processing

Include Unstructured documents in automation Journey

Extracting information from unstructured data sources and documents and convert them in the standardized format to improve yield from automation
Summaries the chat transcripts, call or from converted structured data extracted from unstructured document

04 Intelligent Automation

Automate which is Repetitive & Rule based

Automate rule-based processes to improve turn around time and accuracy of the output
Document Generation
Answering queries 


05 Process Re-Engineering

Re-imagine existing Processes

Re-imagine operating model
Generating Model Processes with less hand off’s and NVA’s
Decouple activities into admin and decision making; strategic decision making 
Centre of Excellence : Consolidate processes, LOB’s which are similar together to drive economies of scale
































public class HospitalServiceImpl implements IHospitalService {
    private final Connection conn;

    public HospitalServiceImpl()
    {
    try {
    	conn = DBConnectionUtil.getConnection();
    }
    catch(SQLException e)
    {
    	System.out.println("Failed to Initialize Service"+e.getMessage());
    }
    
    }
    
    // Updated constructor now throws IOException in addition to SQLException
//    public HospitalServiceImpl() throws SQLException, IOException {
//        this.conn = DBConnectionUtil.getConnection();
//    }

    @Override
    public Appointment getAppointmentById(int appointmentId) throws SQLException {
        String sql = "SELECT * FROM appointment WHERE appointment_id = ?";
        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setInt(1, appointmentId);
            try (ResultSet rs = ps.executeQuery()) {
                if (rs.next()) {
                    return mapResultSetToAppointment(rs);
                } else {
                    return null;
                }
            }
        }
    }

    @Override
    public List<Appointment> getAppointmentsForPatient(int patientId)
            throws SQLException, PatientNumberNotFoundException {
        String sql = "SELECT * FROM appointment WHERE patient_id = ?";
        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setInt(1, patientId);
            try (ResultSet rs = ps.executeQuery()) {
                List<Appointment> list = new ArrayList<>();
                while (rs.next()) {
                    list.add(mapResultSetToAppointment(rs));
                }
                if (list.isEmpty()) {
                    throw new PatientNumberNotFoundException(
                        "No appointments found for patient ID: " + patientId
                    );
                }
                return list;
            }
        }
    }

    @Override
    public List<Appointment> getAppointmentsForDoctor(int doctorId) throws SQLException {
        String sql = "SELECT * FROM appointment WHERE doctor_id = ?";
        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setInt(1, doctorId);
            try (ResultSet rs = ps.executeQuery()) {
                List<Appointment> list = new ArrayList<>();
                while (rs.next()) {
                    list.add(mapResultSetToAppointment(rs));
                }
                return list;
            }
        }
    }

    @Override
    public boolean scheduleAppointment(Appointment appointment) throws SQLException {
        String sql = "INSERT INTO appointment (patient_id, doctor_id, appointment_date, description) "
                   + "VALUES (?, ?, ?, ?)";
        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setInt(1, appointment.getPatientId());
            ps.setInt(2, appointment.getDoctorId());
            ps.setDate(3, java.sql.Date.valueOf(appointment.getAppointmentDate()));
            ps.setString(4, appointment.getDescription());
            return ps.executeUpdate() == 1;
        }
    }

    @Override
    public boolean updateAppointment(Appointment appointment) throws SQLException {
        String sql = "UPDATE appointment SET patient_id=?, doctor_id=?, appointment_date=?, "
                   + "description=? WHERE appointment_id=?";
        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setInt(1, appointment.getPatientId());
            ps.setInt(2, appointment.getDoctorId());
            ps.setDate(3, java.sql.Date.valueOf(appointment.getAppointmentDate()));
            ps.setString(4, appointment.getDescription());
            ps.setInt(5, appointment.getAppointmentId());
            return ps.executeUpdate() == 1;
        }
    }

    @Override
    public boolean cancelAppointment(int appointmentId) throws SQLException {
        String sql = "DELETE FROM appointment WHERE appointment_id = ?";
        try (PreparedStatement ps = conn.prepareStatement(sql)) {
            ps.setInt(1, appointmentId);
            return ps.executeUpdate() == 1;
        }
    }

    private Appointment mapResultSetToAppointment(ResultSet rs) throws SQLException {
        int id   = rs.getInt("appointment_id");
        int pid  = rs.getInt("patient_id");
        int did  = rs.getInt("doctor_id");
        LocalDate date = rs.getDate("appointment_date").toLocalDate();
        String desc    = rs.getString("description");
        return new Appointment(id, pid, did, date, desc);
    }
}
	
	public class MainModule {
	    private static IHospitalService service;

	    public static void main(String[] args) {
	        try {
	            service = new HospitalServiceImpl();
	        } catch (SQLException | IOException e) {
	            System.err.println("Failed to initialize service: " + e.getMessage());
	            return;
	        }

	        Scanner scanner = new Scanner(System.in);
	        int choice;

	        do {
	            System.out.println("=== Hospital Management System ===");
	            System.out.println("1. Get Appointment by ID");
	            System.out.println("2. Get Appointments for Patient");
	            System.out.println("3. Get Appointments for Doctor");
	            System.out.println("4. Schedule Appointment");
	            System.out.println("5. Update Appointment");
	            System.out.println("6. Cancel Appointment");
	            System.out.println("7. Exit");
	            System.out.print("Enter choice: ");

	            choice = Integer.parseInt(scanner.nextLine());

	            switch (choice) {
	                case 1:
	                    getAppointmentById(scanner);
	                    break;
	                case 2:
	                    getAppointmentsForPatient(scanner);
	                    break;
	                case 3:
	                    getAppointmentsForDoctor(scanner);
	                    break;
	                case 4:
	                    scheduleAppointment(scanner);
	                    break;
	                case 5:
	                    updateAppointment(scanner);
	                    break;
	                case 6:
	                    cancelAppointment(scanner);
	                    break;
	                case 7:
	                    System.out.println("Exiting...");
	                    break;
	                default:
	                    System.out.println("Invalid choice. Try again.");
	            }
	        } while (choice != 7);

	        scanner.close();
	    }

	    private static void getAppointmentById(Scanner scanner) {
	        try {
	            System.out.print("Enter Appointment ID: ");
	            int id = Integer.parseInt(scanner.nextLine());
	            Appointment appt = service.getAppointmentById(id);
	            System.out.println(appt != null ? appt : "No appointment found.");
	        } catch (Exception e) {
	            System.err.println("Error: " + e.getMessage());
	        }
	    }

	    private static void getAppointmentsForPatient(Scanner scanner) {
	        try {
	            System.out.print("Enter Patient ID: ");
	            int pid = Integer.parseInt(scanner.nextLine());
	            List<Appointment> list = service.getAppointmentsForPatient(pid);
	            list.forEach(System.out::println);
	        } catch (PatientNumberNotFoundException e) {
	            System.err.println(e.getMessage());
	        } catch (Exception e) {
	            System.err.println("Error: " + e.getMessage());
	        }
	    }

	    private static void getAppointmentsForDoctor(Scanner scanner) {
	        try {
	            System.out.print("Enter Doctor ID: ");
	            int did = Integer.parseInt(scanner.nextLine());
	            List<Appointment> list = service.getAppointmentsForDoctor(did);
	            list.forEach(System.out::println);
	        } catch (Exception e) {
	            System.err.println("Error: " + e.getMessage());
	        }
	    }

	    private static void scheduleAppointment(Scanner scanner) {
	        try {
	            System.out.print("Patient ID: "); int pid = Integer.parseInt(scanner.nextLine());
	            System.out.print("Doctor ID: "); int did = Integer.parseInt(scanner.nextLine());
	            System.out.print("Date (YYYY-MM-DD): "); LocalDate date = LocalDate.parse(scanner.nextLine());
	            System.out.print("Description: "); String desc = scanner.nextLine();
	            Appointment appt = new Appointment(0, pid, did, date, desc);
	            boolean success = service.scheduleAppointment(appt);
	            System.out.println(success ? "Scheduled successfully." : "Failed to schedule.");
	        } catch (Exception e) {
	            System.err.println("Error: " + e.getMessage());
	        }
	    }

	    private static void updateAppointment(Scanner scanner) {
	        try {
	            System.out.print("Appointment ID to update: "); int id = Integer.parseInt(scanner.nextLine());
	            System.out.print("New Patient ID: "); int pid = Integer.parseInt(scanner.nextLine());
	            System.out.print("New Doctor ID: "); int did = Integer.parseInt(scanner.nextLine());
	            System.out.print("New Date (YYYY-MM-DD): "); LocalDate date = LocalDate.parse(scanner.nextLine());
	            System.out.print("New Description: "); String desc = scanner.nextLine();
	            Appointment appt = new Appointment(id, pid, did, date, desc);
	            boolean success = service.updateAppointment(appt);
	            System.out.println(success ? "Updated successfully." : "Failed to update.");
	        } catch (Exception e) {
	            System.err.println("Error: " + e.getMessage());
	        }
	    }

	    private static void cancelAppointment(Scanner scanner) {
	        try {
	            System.out.print("Appointment ID to cancel: ");
	            int id = Integer.parseInt(scanner.nextLine());
	            boolean success = service.cancelAppointment(id);
	            System.out.println(success ? "Cancelled successfully." : "Failed to cancel.");
	        } catch (Exception e) {
	            System.err.println("Error: " + e.getMessage());
	        }
	    }
	}
	





	public class DBConnectionUtil {

		 private static final String DB_URL = "jdbc:mysql://localhost:3306/hospital_management_system"; // Replace with your database URL
		    private static final String DB_USER = "root"; // Replace with your database username
		    private static final String DB_PASSWORD = "anamlalkot"; // Replace with your database password

		    private static Connection connection = null;

		    private DBConnectionUtil() {
		        // Private constructor to prevent unnecessary object creation
		    }

		    public static Connection getConnection() throws SQLException {
		        if (connection == null || connection.isClosed()) {
		            try {
		                Class.forName("com.mysql.cj.jdbc.Driver");
		                connection = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD);
		            } catch (ClassNotFoundException e) {
		                throw new SQLException("Failed to load JDBC driver: " + e.getMessage());
		            }
		        }
		        return connection;
		    }

		    public static void closeConnection() throws SQLException {
		        if (connection != null && !connection.isClosed()) {
		            connection.close();
		            connection = null;
		        }
		    }}













g
y
yyygg
g
g
h
g
g
g
g





package dao;

import entity.Appointment;
import entity.Doctor;
import entity.Patient;
import exception.PatientNumberNotFoundException;

import java.util.List;

public interface IHospitalService {
    Appointment getAppointmentById(int appointmentId)  throws PatientNumberNotFoundException ;
    List<Appointment> getAppointmentsForPatient(int patientId);
    List<Appointment> getAppointmentsForDoctor(int doctorId);
    boolean scheduleAppointment(Appointment appointment);
    boolean updateAppointment(Appointment appointment);
    boolean cancelAppointment(int appointmentId);
}















[26/05, 6:38 pm] Musaddique: package dao;

import entity.Appointment;
import entity.Doctor;
import entity.Patient;
import exception.PatientNumberNotFoundException;

import java.util.List;

public interface IHospitalService {
    Appointment getAppointmentById(int appointmentId)  throws PatientNumberNotFoundException ;
    List<Appointment> getAppointmentsForPatient(int patientId);
    List<Appointment> getAppointmentsForDoctor(int doctorId);
    boolean scheduleAppointment(Appointment appointment);
    boolean updateAppointment(Appointment appointment);
    boolean cancelAppointment(int appointmentId);
}
[26/05, 6:38 pm] Musaddique: ye wala part empty reh gaya Hospital service me 

    @Override
    public List<Appointment> getAppointmentsForDoctor(int doctorId) {
        // Similar implementation as getAppointmentsForPatient
        return null;
    }

usme se comment hata de shak hoga
[26/05, 6:38 pm] Musaddique: entity me jo appointment he usme 

public class Appointment {
    private int appointmentId;
    private int patientId;
    private int doctorId;
    private Date appointmentDate;
    private String description;

    public Appointment() {
    }
    public Appointment(int patientId, int doctorId, Date appointmentDate, String description)
    {
    	  this.patientId = patientId;
    	  this.doctorId = doctorId;
    	  this.appointmentDate = appointmentDate;
          this.description = description;
    }
    public Appointment(int appointmentId, int patientId, int doctorId, Date appointmentDate, String description) {
        this.appointmentId = appointmentId;
        this.patientId = patientId;
        this.doctorId = doctorId;
        this.appointmentDate = appointmentDate;
        this.description = description;
    }

aisa kar



















7DB CONNECTION 

package util;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;


public class DBConnectionUtil {

    private static final String DB_URL = "jdbc:mysql://localhost:3306/hospital_management_system"; // Replace with your database URL
    private static final String DB_USER = "root"; // Replace with your database username
    private static final String DB_PASSWORD = "anamlalkot@123"; // Replace with your database password

    private static Connection connection = null;

    private DBConnectionUtil() {
        // Private constructor to prevent unnecessary object creation
    }

    public static Connection getConnection() throws SQLException {
        if (connection == null || connection.isClosed()) {
            try {
                Class.forName("com.mysql.cj.jdbc.Driver");
                connection = DriverManager.getConnection(DB_URL, DB_USER, DB_PASSWORD);
            } catch (ClassNotFoundException e) {
                throw new SQLException("Failed to load JDBC driver: " + e.getMessage());
            }
        }
        return connection;
    }

    public static void closeConnection() throws SQLException {
        if (connection != null && !connection.isClosed()) {
            connection.close();
            connection = null;
        }
    }
}




main module
package main;

import dao.HospitalServiceImpl;
import entity.Appointment;
import exception.PatientNumberNotFoundException;
import java.text.SimpleDateFormat;
import java.util.List;
import java.util.Scanner;
import java.util.Date;
import java.text.ParseException;

public class MainModule {

    private static final HospitalServiceImpl hospitalService = new HospitalServiceImpl();
    private static final Scanner scanner = new Scanner(System.in);

    public static void main(String[] args) {
        displayMenu();
    }

    private static void displayMenu() {
        boolean exit = false;
        while (!exit) {
            System.out.println("\nHospital Management System");
            System.out.println("1. View Appointment Details");
            System.out.println("2. View Appointments for Patient");
            System.out.println("3. View Appointments for Doctor");
            System.out.println("4. Schedule Appointment");
            System.out.println("5. Update Appointment");
            System.out.println("6. Cancel Appointment");
            System.out.println("7. Exit");
            System.out.print("Enter your choice: ");

            int choice = scanner.nextInt();
            scanner.nextLine(); // Consume newline character

            switch (choice) {
                case 1:
                    viewAppointmentDetails();
                    break;
                case 2:
                    viewAppointmentsForPatient();
                    break;
                case 3:
                    viewAppointmentsForDoctor();
                    break;
                case 4:
                    scheduleAppointment();
                    break;
                case 5:
                    updateAppointment();
                    break;
                case 6:
                    cancelAppointment();
                    break;
                case 7:
                    exit = true;
                    break;
                default:
                    System.out.println("Invalid choice! Please enter a number between 1 and 7.");
            }
        }
        System.out.println("Thank you for using the Hospital Management System. Goodbye!");
    }

    private static void viewAppointmentDetails() {
        System.out.print("Enter Appointment ID: ");
        int appointmentId = scanner.nextInt();
        scanner.nextLine(); // Consume newline character

        try {
            Appointment appointment = hospitalService.getAppointmentById(appointmentId);
            if (appointment != null) {
                System.out.println("Appointment Details:");
                System.out.println(appointment);
            } else {
                System.out.println("Appointment not found.");
            }
        } catch (PatientNumberNotFoundException e) {
            System.out.println("Error: " + e.getMessage());
        }
    }

    private static void viewAppointmentsForPatient() {
        System.out.print("Enter Patient ID: ");
        int patientId = scanner.nextInt();
        scanner.nextLine(); // Consume newline character

        List<Appointment> appointments = hospitalService.getAppointmentsForPatient(patientId);
        if (appointments != null && !appointments.isEmpty()) {
            System.out.println("Appointments for Patient:");
            for (Appointment appointment : appointments) {
                System.out.println(appointment);
            }
        } else {
            System.out.println("No appointments found for the patient.");
        }
    }

    private static void viewAppointmentsForDoctor() {
        System.out.print("Enter Doctor ID: ");
        int doctorId = scanner.nextInt();
        scanner.nextLine(); // Consume newline character

        List<Appointment> appointments = hospitalService.getAppointmentsForDoctor(doctorId);
        if (appointments != null && !appointments.isEmpty()) {
            System.out.println("Appointments for Doctor:");
            for (Appointment appointment : appointments) {
                System.out.println(appointment);
            }
        } else {
            System.out.println("No appointments found for the doctor.");
        }
    }

    
    private static void scheduleAppointment() {
        System.out.println("Schedule Appointment:");
        
        // Gather appointment details directly
        System.out.print("Enter Patient ID: ");
        int patientId = scanner.nextInt();
        scanner.nextLine(); // Consume newline character
        System.out.print("Enter Doctor ID: ");
        int doctorId = scanner.nextInt();
        scanner.nextLine(); // Consume newline character
        System.out.print("Enter Appointment Date (YYYY-MM-DD): ");
        String appointmentDateStr = scanner.nextLine();
        System.out.print("Enter Description: ");
        String description = scanner.nextLine();

        try {
            SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
            Date appointmentDate = sdf.parse(appointmentDateStr);
            
            // Create Appointment object
            Appointment appointment = new Appointment(patientId, doctorId, appointmentDate, description);
            
            // Attempt to schedule the appointment
            boolean success = hospitalService.scheduleAppointment(appointment);
            
            if (success) {
                System.out.println("Appointment scheduled successfully.");
            } else {
                System.out.println("Failed to schedule appointment.");
            }
        } catch (ParseException e) {
            System.out.println("Invalid date format. Please enter date in YYYY-MM-DD format.");
        }
    }


    private static void updateAppointment() {
        System.out.print("Enter Appointment ID to update: ");
        int appointmentId = scanner.nextInt();
        scanner.nextLine(); // Consume newline character
        
        try {
            // Check if the appointment exists
            Appointment appointment = hospitalService.getAppointmentById(appointmentId);
            if (appointment != null) {
                System.out.println("Update Appointment:");
                
                // Gather updated appointment details directly
                System.out.print("Enter Patient ID: ");
                int patientId = scanner.nextInt();
                scanner.nextLine(); // Consume newline character
                System.out.print("Enter Doctor ID: ");
                int doctorId = scanner.nextInt();
                scanner.nextLine(); // Consume newline character
                System.out.print("Enter Appointment Date (YYYY-MM-DD): ");
                String appointmentDateStr = scanner.nextLine();
                System.out.print("Enter Description: ");
                String description = scanner.nextLine();

                try {
                    SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd");
                    Date appointmentDate = sdf.parse(appointmentDateStr);
                    
                    // Create updated Appointment object
                    Appointment updatedAppointment = new Appointment(appointmentId, patientId, doctorId, appointmentDate, description);
                    
                    // Attempt to update the appointment
                    boolean success = hospitalService.updateAppointment(updatedAppointment);
                    
                    if (success) {
                        System.out.println("Appointment updated successfully.");
                        return;
                    }
                } catch (ParseException e) {
                    System.out.println("Invalid date format. Please enter date in YYYY-MM-DD format.");
                }
                
                System.out.println("Failed to update appointment.");
            } else {
                System.out.println("Appointment not found.");
            }
        } catch (PatientNumberNotFoundException e) {
            System.out.println("Error: " + e.getMessage());
        }
    }
    
    
    private static void cancelAppointment() {
        System.out.print("Enter Appointment ID to cancel: ");
        int appointmentId = scanner.nextInt();
        scanner.nextLine(); // Consume newline character
        boolean success = hospitalService.cancelAppointment(appointmentId);
        if (success) {
            System.out.println("Appointment canceled successfully.");
        } else {
            System.out.println("Failed to cancel appointment.");
        }
    }

}














package dao;

import entity.Appointment;
import entity.Doctor;
import entity.Patient;
import exception.PatientNumberNotFoundException;
import util.DBConnectionUtil;

import java.sql.Connection;
import java.sql.*;
import java.util.ArrayList;
import java.util.List;

public class HospitalServiceImpl implements IHospitalService {
    private Connection connection;

    public HospitalServiceImpl() {
        try {
            this.connection = DBConnectionUtil.getConnection();
        } catch (SQLException e) {
        	System.err.println("Error: Unable to establish database connection.");
            e.printStackTrace();

        }
    }

    @Override
    public Appointment getAppointmentById(int appointmentId)  throws PatientNumberNotFoundException{
        Appointment appointment = null;
        PreparedStatement statement = null;
        ResultSet resultSet = null;

        try {
            String query = "SELECT * FROM appointments WHERE appointment_id = ?";
            statement = connection.prepareStatement(query);
            statement.setInt(1, appointmentId);
            resultSet = statement.executeQuery();

            if (resultSet.next()) {
                appointment = new Appointment();
                appointment.setAppointmentId(resultSet.getInt("appointment_id"));
                appointment.setPatientId(resultSet.getInt("patient_id"));
                appointment.setDoctorId(resultSet.getInt("doctor_id"));
                appointment.setAppointmentDate(resultSet.getDate("appointment_date"));
                appointment.setDescription(resultSet.getString("description"));
            } else {
                throw new PatientNumberNotFoundException("Patient with appointment ID " + appointmentId + " not found");
            }
        } catch (SQLException e) {
        	 System.err.println("Error: Failed to retrieve appointment details from the database.");
            e.printStackTrace();
          
        } finally {
            // Close resources
            try {
                if (resultSet != null) resultSet.close();
                if (statement != null) statement.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

        return appointment;
    }

    @Override
    public List<Appointment> getAppointmentsForPatient(int patientId) {
        List<Appointment> appointments = new ArrayList<>();
        PreparedStatement statement = null;
        ResultSet resultSet = null;

        try {
            String query = "SELECT * FROM appointments WHERE patient_id = ?";
            statement = connection.prepareStatement(query);
            statement.setInt(1, patientId);
            resultSet = statement.executeQuery();

            while (resultSet.next()) {
                Appointment appointment = new Appointment();
                appointment.setAppointmentId(resultSet.getInt("appointment_id"));
                appointment.setPatientId(resultSet.getInt("patient_id"));
                appointment.setDoctorId(resultSet.getInt("doctor_id"));
                appointment.setAppointmentDate(resultSet.getDate("appointment_date"));
                appointment.setDescription(resultSet.getString("description"));
                appointments.add(appointment);
            }
        } catch (SQLException e) {
            e.printStackTrace();
            // Handle database error
        } finally {
            // Close resources
            try {
                if (resultSet != null) resultSet.close();
                if (statement != null) statement.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }

        return appointments;
    }

    @Override
    public List<Appointment> getAppointmentsForDoctor(int doctorId) {
        // Similar implementation as getAppointmentsForPatient
        return null;
    }

    @Override
    public boolean scheduleAppointment(Appointment appointment) {
        PreparedStatement statement = null;

        try {
            String query = "INSERT INTO appointments (patient_id, doctor_id, appointment_date, description) VALUES (?, ?, ?, ?)";
            statement = connection.prepareStatement(query);
            statement.setInt(1, appointment.getPatientId());
            statement.setInt(2, appointment.getDoctorId());
            statement.setDate(3, new Date(appointment.getAppointmentDate().getTime()));
            statement.setString(4, appointment.getDescription());

            int rowsInserted = statement.executeUpdate();
            return rowsInserted > 0;
        } catch (SQLException e) {
            e.printStackTrace();
            // Handle database error
            return false;
        } finally {
            // Close resources
            try {
                if (statement != null) statement.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }

    @Override
    public boolean updateAppointment(Appointment appointment) {
        PreparedStatement statement = null;

        try {
            String query = "UPDATE appointments SET patient_id = ?, doctor_id = ?, appointment_date = ?, description = ? WHERE appointment_id = ?";
            statement = connection.prepareStatement(query);
            statement.setInt(1, appointment.getPatientId());
            statement.setInt(2, appointment.getDoctorId());
            statement.setDate(3, new Date(appointment.getAppointmentDate().getTime()));
            statement.setString(4, appointment.getDescription());
            statement.setInt(5, appointment.getAppointmentId());

            int rowsUpdated = statement.executeUpdate();
            return rowsUpdated > 0;
        } catch (SQLException e) {
            e.printStackTrace();
            // Handle database error
            return false;
        } finally {
            // Close resources
            try {
                if (statement != null) statement.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
    }

    @Override
    public boolean cancelAppointment(int appointmentId) {
        PreparedStatement statement = null;

        try {
            String query = "DELETE FROM appointments WHERE appointment_id = ?";
            statement = connection.prepareStatement(query);
            statement.setInt(1, appointmentId);

            int rowsDeleted = statement.executeUpdate();
            return rowsDeleted > 0;
        } catch (SQLException e) {
            e.printStackTrace();
            // Handle database error
            return false;
        } finally {
            // Close resources
            try {
                if (statement != null) statement.close();
            } catch (SQLException e) {
                e.printStackTrace();
            }
        }
}
  }





package dao;

import entity.Appointment;
import entity.Doctor;
import entity.Patient;
import exception.PatientNumberNotFoundException;

import java.util.List;

public interface IHospitalService {
    Appointment getAppointmentById(int appointmentId)  throws PatientNumberNotFoundException ;
    List<Appointment> getAppointmentsForPatient(int patientId);
    List<Appointment> getAppointmentsForDoctor(int doctorId);
    boolean scheduleAppointment(Appointment appointment);
    boolean updateAppointment(Appointment appointment);
    boolean cancelAppointment(int appointmentId);
}




entity me jo appointment he usme 

public class Appointment {
    private int appointmentId;
    private int patientId;
    private int doctorId;
    private Date appointmentDate;
    private String description;

    public Appointment() {
    }
    public Appointment(int patientId, int doctorId, Date appointmentDate, String description)
    {
    	  this.patientId = patientId;
    	  this.doctorId = doctorId;
    	  this.appointmentDate = appointmentDate;
          this.description = description;
    }
    public Appointment(int appointmentId, int patientId, int doctorId, Date appointmentDate, String description) {
        this.appointmentId = appointmentId;
        this.patientId = patientId;
        this.doctorId = doctorId;
        this.appointmentDate = appointmentDate;
        this.description = description;
    }

aisa kar





















// Project: jdbc-demo // Directory structure: // src/main/java/com/example/ // ├── dao/ // │   ├── EmployeeDAO.java // │   └── EmployeeDAOImpl.java // ├── entity/ // │   └── Employee.java // ├── util/ // │   └── DBUtil.java // └── Main.java

// src/main/java/com/example/entity/Employee.java package com.example.entity;

public class Employee { private int id; private String name; private double salary;

public Employee() {}

public Employee(int id, String name, double salary) {
    this.id = id;
    this.name = name;
    this.salary = salary;
}

public int getId() {
    return id;
}

public void setId(int id) {
    this.id = id;
}

public String getName() {
    return name;
}

public void setName(String name) {
    this.name = name;
}

public double getSalary() {
    return salary;
}

public void setSalary(double salary) {
    this.salary = salary;
}

@Override
public String toString() {
    return "Employee{id=" + id + ", name='" + name + "', salary=" + salary + '}';
}

}

// src/main/java/com/example/util/DBUtil.java package com.example.util;

import java.sql.Connection; import java.sql.DriverManager; import java.sql.SQLException;

public class DBUtil { private static final String URL = "jdbc:mysql://localhost:3306/testdb"; private static final String USER = "root"; private static final String PASS = "secret";

static {
    try {
        Class.forName("com.mysql.cj.jdbc.Driver");
    } catch (ClassNotFoundException e) {
        throw new RuntimeException("MySQL JDBC driver not found", e);
    }
}

public static Connection getConnection() throws SQLException {
    return DriverManager.getConnection(URL, USER, PASS);
}

}

// src/main/java/com/example/dao/EmployeeDAO.java package com.example.dao;

import com.example.entity.Employee; import java.util.List;

public interface EmployeeDAO { Employee findById(int id); List<Employee> findAll(); int save(Employee employee); boolean update(Employee employee); boolean delete(int id); }

// src/main/java/com/example/dao/EmployeeDAOImpl.java package com.example.dao;

import com.example.entity.Employee; import com.example.util.DBUtil;

import java.sql.*; import java.util.ArrayList; import java.util.List;

public class EmployeeDAOImpl implements EmployeeDAO { @Override public Employee findById(int id) { String sql = "SELECT id, name, salary FROM employees WHERE id = ?"; try (Connection conn = DBUtil.getConnection(); PreparedStatement pstmt = conn.prepareStatement(sql)) { pstmt.setInt(1, id); try (ResultSet rs = pstmt.executeQuery()) { if (rs.next()) { return new Employee( rs.getInt("id"), rs.getString("name"), rs.getDouble("salary") ); } } } catch (SQLException e) { e.printStackTrace(); } return null; }

@Override
public List<Employee> findAll() {
    List<Employee> list = new ArrayList<>();
    String sql = "SELECT id, name, salary FROM employees";
    try (Connection conn = DBUtil.getConnection();
         Statement stmt = conn.createStatement();
         ResultSet rs = stmt.executeQuery(sql)) {
        while (rs.next()) {
            list.add(new Employee(
                rs.getInt("id"),
                rs.getString("name"),
                rs.getDouble("salary")
            ));
        }

